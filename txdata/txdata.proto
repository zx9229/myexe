syntax = "proto3";

package txdata;

import public "google/protobuf/timestamp.proto";

// 注意: 务必要和各结构体的序号对应起来. 校验的命令如下所示:
// Linux  : grep    "^message" txdata.proto | awk -F" " 'BEGIN{cnt=0}{print"ID_"$2,"= "cnt++";"}'
// Linux  : grep    "^message" txdata.proto
// Windows: findstr "^message" txdata.proto
enum MsgType {
    Zero1               =  0;
    ID_DataPsh          =  1;
    ID_DataAck          =  2;
    ID_CommonReq        =  3;
    ID_CommonRsp        =  4;
    ID_ConnectionInfo   =  5;
    ID_ConnectReq       =  6;
    ID_ConnectRsp       =  7;
    ID_DisconnectedData =  8;
    ID_OnlineNotice     =  9;
    ID_CommonErrMsg     = 10;
    ID_QueryRecordReq   = 11;
    ID_QueryRecordRsp   = 12;
    ID_ExecCmdReq       = 13;
    ID_ExecCmdRsp       = 14;
    ID_EchoItem         = 15;
    ID_ReportDataItem   = 16;
    ID_SendMailItem     = 17;
}

//一个占位符结构体.
message DataPlaceholder {
}

//Psh:Push,Tx:transmit,Tt:total,
//(空,表示根节点)
//在整个传输中,TtSender和TtRecver可以都有值.
//在某次传输中,TxSender和TxRecver必须有一方是空(根节点),这样可以直接判断出某次传输的方向.
//还有就是,这样,数据必定先流向根节点,可以让根节点去重.
//假定有场景:A-=>ROOT<=-B
//SendUID(有值),A     SendUID(有值),B       SendUID(有值),
//SendNo (有值),      SendNo (有值),        SendNo (零值),
//RecvUID(有值),B     RecvUID(有值),A       RecvUID(有值),A
//RecvNo (零值),      RecvNo (有值),        RecvNo (有值),
//请求发送中(A=>根=>B),响应发送往ROOT(B=>根),响应回复中(根=>A),
message DataPsh {
    string  SenderID = 1;//(本次传输的)发送方.
    string  RecverID = 2;//(本次传输的)接收方.(空,表示发送到根节点)
    string  SendUID  = 3;//(整个传输的)发送方.
    int64   SendNo   = 4;//(TtSender+TtSeqNo)唯一标识一个消息.
    string  RecvUID  = 5;//(整个传输的)接收方.
    int64   RecvNo   = 6;//(整个传输的)接收方.
    MsgType PshType  = 7;//传输的数据类型.
    bytes   PshData  = 8;//传输的数据内容.
    bool    UpCache  = 9;//最先收到本条数据的节点,负有缓存本条数据的义务.
}

//Acknowledgement
message DataAck {
    string  SenderID = 1;//(本次传输的)发送方.
    string  RecverID = 2;//(本次传输的)接收方.(空,表示发送到根节点)
    string  SendUID  = 3;//(TtSender+TtSeqNo)唯一标识一个消息.
    int64   SendNo   = 4;//(TtSender+TtSeqNo)唯一标识一个消息.
    MsgType AckType  = 5;//预留字段.
    bytes   AckData  = 6;//预留字段.
    int32   ErrNo    = 7;//(成功),(中途发现无法到达对方,然后收到不可达的回复),(重复发送).
    string  ErrMsg   = 8;//对ErrNo的解释.
}

message CommonReq {
    string                    SenderID    =  1;//消息的发送者.
    string                    RecverID    =  2;//消息的接收者.
    int64                     RequestID   =  4;//为0表示不需要回应这个消息(不需要发送CommonRsp消息).
    bool                      CrossServer =  3;
    MsgType                   ReqType     =  5;
    bytes                     ReqData     =  6;
    google.protobuf.Timestamp ReqTime     =  7;//预留字段.
    int64                     RefNum      =  8;//预留字段.
}

//(FromServer==true && ErrNo!=0)的一个情况举例:SERVER收到了请求结构体,但是解析请求结构体失败,然后不知道怎么赋值响应结构体,便为ErrNo赋值.
message CommonRsp {
    string                    SenderID    =  1;
    string                    RecverID    =  2;
    int64                     RequestID   =  4;
    bool                      CrossServer =  3;
    MsgType                   RspType     =  5;
    bytes                     RspData     =  6;
    google.protobuf.Timestamp RspTime     =  7;//预留字段.
    int64                     RefNum      =  8;//预留字段.
    bool                      IsLast      =  9;//最后一条响应的标志.
    int32                     ErrNo       = 10;
    string                    ErrMsg      = 11;//对ErrNo的解释.
    int32                     State       = 12;//预留字段(可以标识出来:刚发送到对端就立即返回一个接收成功的标识,响应的顺序号,最后一个响应的标识[同IsLast的含义],等)
}

message ConnectionInfo {
    enum LinkType {
        Zero3   = 0;
        CONNECT = 1; //以client的身份,connect到server,建立起来的连接.
        ACCEPT  = 2; //以server的身份,accept,建立起来的连接.
    }
    string    UserID    = 1;//为空表示ROOT节点.
    string    BelongID  = 2;//为空表示ROOT节点.
    string    Version   = 3;//版本号
    LinkType  LinkMode  = 4;//连接方向
    int32     ExePid    = 5;//进程ID
    string    ExePath   = 6;//程序路径
    string    Remark    = 7;//备注
}

message ConnectReq {
    ConnectionInfo  InfoReq = 1;
    repeated string Pathway = 2;//两者之间要按顺序走哪些AGENT
/* ParentA:(父亲agent), ParentC1:(父亲client1), SonA:(儿子agent), GrandsonA:(孙子agent)
ParentA
│  ParentC1               ParentA收到的Pathway=[]
│  ParentC2               ParentA收到的Pathway=[]
│
└─SonA                    ParentA收到的Pathway=[SonA]
    │  SonC1              ParentA收到的Pathway=[SonA]
    │  SonC2              ParentA收到的Pathway=[SonA]
    │
    └─GrandsonA           ParentA收到的Pathway=[GrandsonA,SonA]
            GrandsonC1    ParentA收到的Pathway=[GrandsonA,SonA]
            GrandsonC2    ParentA收到的Pathway=[GrandsonA,SonA]
*/
}

message ConnectRsp {
    ConnectionInfo  InfoReq = 1;
    ConnectionInfo  InfoRsp = 2;
    int32           ErrNo   = 3;
    string          ErrMsg  = 4;
}

message DisconnectedData {
    ConnectionInfo  Info    = 1;
}

//从根节点发往叶子节点方向的通知,表达"收到通知的节点,此刻都能和root联通"
message OnlineNotice {
    bool RootIsOnline = 1;
}

message CommonErrMsg {
    string    UserID        = 1;//发现错误的用户.
    repeated string Pathway = 2;//消息的传送路径.(预留字段)
    string    Message       = 3;
}

//从ROOT查询记录的请求.
message QueryRecordReq {
    string         UserID = 1;//要查询的用户.
    int64          SeqNo  = 2;//要查询的编号.
}

//从ROOT查询记录的响应.
message QueryRecordRsp {
    string         UserID = 1;
    int64          SeqNo  = 2;
    repeated bytes Data   = 3;//可以用slice2msg解析.
}

//执行命令的请求.
message ExecCmdReq {
    string Cmd      = 1;
}

//执行命令的响应.
message ExecCmdRsp {
    string Reply    = 1;
    int32  ReplyIdx = 2;
    bool   IsLast   = 3;
}

message EchoItem {
    string LocalID  = 1;
    string RemoteID = 2;
    string Data     = 3;
}

message ReportDataItem {
    string Topic = 1;//Data的主题.
    string Data  = 2;
}

//发送邮件的项
message SendMailItem {
    string Username    = 1;
    string Password    = 2;
    string SmtpAddr    = 3;
    string To          = 4;
    string Subject     = 5;
    string ContentType = 6;
    string Content     = 7;
}
